{
  "language": "Solidity",
  "sources": {
    "contracts/Qvoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../EventsQv/ProposalEvents.sol\";\r\nimport \"../Library/VoterLibrary.sol\";\r\nimport \"../Library/ProposalLibrary.sol\";\r\nimport \"../Library/UserProposalLibrary.sol\";\r\nimport \"../QvToken/QvToken.sol\";\r\nimport \"../QvToken/ERC20.sol\";\r\nimport \"../QvToken/Context.sol\";\r\nimport \"../QvToken/IERC20.sol\";\r\nimport \"../QvToken/IERC20Metadata.sol\";\r\n\r\n// why Poll is inheriting from ReentrancyGuard, CustomOwnable, brainchainEvents ?\r\ncontract Qvoting is proposalEvents, QVtoken {\r\n    // what is the use of pollLibrary and UserPollLibrary : difference b/w them?\r\n    using proposalLibrary for proposalLibrary.proposal;\r\n    using UserProposalLibrary for UserProposalLibrary.UserProposal;\r\n    using voterLibrary for voterLibrary.voter;\r\n    //this is not understandable?? SafeERC20 ??\r\n    // using SafeERC20 for IERC20;  // how do you think ki lets use this here and what does safeERC20 signifies?\r\n\r\n    // Iadmin public admin;   // use of admin here !!  interface se instance ku bnaya .. new karke bhi toh bna sakte tha\r\n    // bool internal isInitialized;\r\n    uint256 private proposalId;\r\n    // address public root; // root signifies ??\r\n    mapping(address => UserProposalLibrary.UserProposal) public userProposal; //address => userPolls\r\n    mapping(uint256 => proposalLibrary.proposal) public proposals; //pollId => pool Detail object\r\n    mapping(address => mapping(uint256 => voterLibrary.voter)) public allVoters;\r\n    mapping(uint256 => bool) validProposals;\r\n\r\n    // proposals[_proposalId].creator;\r\n\r\n    // mapping(uint => bool) public poll_NFT;\r\n\r\n    // ye tha is function mai 3rd argument : address _user\r\n    // function initialize(address _root, address _admin) public {\r\n    //     require(!isInitialized,\"initialized\");\r\n    //     isInitialized = true;\r\n    //     _setOwner(_root);\r\n    //     root = _root;\r\n    //     admin = Iadmin(_admin);\r\n    // }\r\n\r\n    // _badgeID,and _token ??\r\n    // why does it have only 1 ques ??\r\n\r\n    function createProposal(\r\n        uint8 _status,\r\n        address[] memory _voters,\r\n        address _creator,\r\n        uint256 _startTime,\r\n        uint256 _expirationTime,\r\n        string memory _disc,\r\n        string[] calldata _option,\r\n        uint256 _voteRight\r\n    ) external {\r\n        // start time and end time should be greater than current time ye hona chahiye but what does mean by \"pool not started\"?\r\n        require(block.timestamp < _startTime, \"proposal not started\");\r\n        require(\r\n            block.timestamp < _expirationTime,\r\n            \"End time should be greater than current time\"\r\n        );\r\n        require(\r\n            _startTime < _expirationTime,\r\n            \"End time should be greater than start time\"\r\n        );\r\n        proposalId++;\r\n        proposals[proposalId].createProposal(\r\n            _status,\r\n            _voters,\r\n            _creator,\r\n            _startTime,\r\n            _expirationTime,\r\n            _disc,\r\n            _voteRight,\r\n            _option\r\n        );\r\n        emit ProposalCreated(\r\n            proposalId,\r\n            _voters,\r\n            _creator,\r\n            _startTime,\r\n            _expirationTime,\r\n            _disc,\r\n            _option\r\n        );\r\n        validProposals[proposalId] = true;\r\n        // 1 -> a=1 b=1 c=1 d=1\r\n        // 10 -> a=10 b=10 c=10 d=10\r\n\r\n        for (uint256 i = 0; i < _voters.length; i++) {\r\n            mint(_voters[i], _voteRight);\r\n            allVoters[_voters[i]][proposalId].createVoter(\r\n                proposalId,\r\n                _voters[i],\r\n                false,\r\n                _voteRight\r\n            );\r\n            emit mintAndburn(\"mint\", _voters[i], _voteRight);\r\n        }\r\n\r\n        userProposal[_msgSender()].updateProposalList(proposalId);\r\n    }\r\n\r\n    function getProposalCount() public view returns (uint256) {\r\n        return proposalId;\r\n    }\r\n\r\n    function responseProposal(\r\n        uint256 _proposalId,\r\n        address _voter,\r\n        string[] memory _hash,\r\n        uint256[] memory v\r\n    ) external {\r\n        // require(Iuser(admin.userContract()).isUserExist(_msgSender()),\"User not exist\");\r\n\r\n        require(validProposals[_proposalId], \"invalid proposalId\");\r\n        require(\r\n            allVoters[_voter][_proposalId].proposalId == _proposalId,\r\n            \"not a valid voter for this proposal\"\r\n        );\r\n\r\n        // ye chaya proposal voter[]!! // access\r\n        require(!allVoters[_voter][_proposalId].hasVoted, \"already voted\");\r\n        require(\r\n            proposals[_proposalId].numOfOptions == _hash.length,\r\n            \"not a valid length of hash response!\"\r\n        );\r\n        uint256 sum = 0;\r\n        for (uint256 i = 0; i < v.length; i++) {\r\n            sum += v[i] * v[i];\r\n        }\r\n        require(\r\n            allVoters[_voter][_proposalId].voteNum >= sum,\r\n            \"not sufficient balance to cast vote\"\r\n        );\r\n\r\n        proposals[_proposalId].responseProposal(_voter, _hash, v);\r\n        userProposal[_msgSender()].updateResponseList(_proposalId, _hash);\r\n\r\n        allVoters[_voter][_proposalId].updateVoteNum();\r\n        allVoters[_voter][_proposalId].hasVoted = true;\r\n        // burn(_voter,proposals[proposalId].voteRight);\r\n        // emit mintAndburn(\"burn\", _voter, proposals[proposalId].voteRight);\r\n    }\r\n\r\n    // mint corresponding to proposal Id\r\n    // burn corresponding to proposal Id\r\n\r\n    function resultOfProposal(uint256 _proposalId)\r\n        public\r\n        view\r\n        returns (uint256, string memory)\r\n    {\r\n        require(validProposals[_proposalId], \"not a valid proposal\");\r\n        // require(proposals[proposalId].status ==3,\"not completed yet\");\r\n        return (\r\n            proposals[_proposalId].votes[proposals[_proposalId].result[1]],\r\n            proposals[_proposalId].result[1]\r\n        );\r\n    }\r\n\r\n    // function mintOwner(uint _proposalId, address[] memory _voters) external returns(bool)\r\n    // {\r\n    //     require(validProposals[_proposalId],\"Proposal do not exist\");\r\n    //     // require(_voteRight >0, \"credits should be greater than zero\");\r\n    //     uint _voteRight = proposals[_proposalId].voteRight;\r\n    //     for(uint256 i=0;i<_voters.length;i++){\r\n    //         mint(_voters[i],_voteRight);\r\n    //         allVoters[_voters[i]][proposalId].createVoter(proposalId, _voters[i], false, _voteRight);\r\n    //         emit mintAndburn(\"mint\",_voters[i],_voteRight);\r\n    //         }\r\n    //     return true;\r\n    // }\r\n\r\n    function burnOwner(uint256 _proposalId, address[] memory _voters)\r\n        external\r\n        returns (bool)\r\n    {\r\n        require(\r\n            block.timestamp > (proposals[_proposalId].expirationTime / 1000),\r\n            \"proposal is not completed yet\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < _voters.length; i++) {\r\n            if (\r\n                // !allVoters[_voters[i]][_proposalId].hasVoted &&\r\n                allVoters[_voters[i]][_proposalId].proposalId == _proposalId &&\r\n                allVoters[_voters[i]][_proposalId].burn == false\r\n            ) {\r\n                burn(_voters[i], proposals[_proposalId].voteRight);\r\n                allVoters[_voters[i]][_proposalId].burn = true;\r\n                emit mintAndburn(\r\n                    \"burn\",\r\n                    _voters[i],\r\n                    proposals[_proposalId].voteRight\r\n                );\r\n                allVoters[_voters[i]][_proposalId].voteNum = 0; // Added\r\n            } else continue;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function winCountLen(uint256 _proposalId) external view returns (uint256) {\r\n        return proposals[_proposalId].winnerCount;\r\n    }\r\n\r\n    // function resultOfProposalId(uint _proposalId) external returns(bool){\r\n    //     require(validProposals[_proposalId],\"not a valid proposal\");\r\n    //     proposals[_proposalId].proposalresult();\r\n    //     uint winnerCounts = proposals[_proposalId].winnerCount;\r\n    //     for(uint i =1; i<=winnerCounts;i++)\r\n    //     {\r\n    //         results[_proposalId][i] = proposals[_proposalId].result[i];\r\n    //     }\r\n    //     return true;\r\n    // }\r\n\r\n    function resultOfProposalbyId(uint256 _proposalId)\r\n        external\r\n        returns (string[] memory)\r\n    {\r\n        require(validProposals[_proposalId], \"not a valid proposal\");\r\n        proposals[_proposalId].proposalresult();\r\n        uint256 _winnerCounts = proposals[_proposalId].winnerCount;\r\n        string[] memory _result = new string[](_winnerCounts);\r\n        for (uint256 i = 1; i <= _winnerCounts; i++) {\r\n            _result[i - 1] = proposals[_proposalId].result[i];\r\n        }\r\n        return _result;\r\n    }\r\n\r\n    function resultOf(uint256 _proposalId) external returns (string memory) {\r\n        require(validProposals[_proposalId], \"not a valid proposal\");\r\n        proposals[_proposalId].proposalresult();\r\n        return proposals[_proposalId].result[1];\r\n    }\r\n\r\n    function optionById(uint256 _proposalId)\r\n        external\r\n        view\r\n        returns (string[] memory)\r\n    {\r\n        require(validProposals[_proposalId], \"not a valid proposal\");\r\n        uint16 _numOfOptions = proposals[_proposalId].numOfOptions;\r\n        string[] memory _option = new string[](_numOfOptions);\r\n        for (uint16 i = 0; i < _numOfOptions; i++) {\r\n            _option[i] = proposals[_proposalId].optionHash[i + 1];\r\n        }\r\n        return _option;\r\n    }\r\n\r\n    function votersById(uint256 _proposalId)\r\n        external\r\n        view\r\n        returns (string[] memory)\r\n    {\r\n        require(validProposals[_proposalId], \"not a valid proposal\");\r\n        uint16 _numOfOptions = proposals[_proposalId].numOfOptions;\r\n        string[] memory _option = new string[](_numOfOptions);\r\n        for (uint16 i = 0; i < _numOfOptions; i++) {\r\n            _option[i] = proposals[_proposalId].optionHash[i + 1];\r\n        }\r\n        return _option;\r\n    }\r\n\r\n    function votesArrayById(uint256 _proposalId)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        require(validProposals[_proposalId], \"not a valid proposal\");\r\n        uint16 _numOfOptions = proposals[_proposalId].numOfOptions;\r\n        uint256[] memory _vote = new uint256[](_numOfOptions);\r\n        for (uint16 i = 0; i < _numOfOptions; i++) {\r\n            _vote[i] = proposals[_proposalId].votes[\r\n                proposals[_proposalId].optionHash[i + 1]\r\n            ];\r\n        }\r\n        return _vote;\r\n    }\r\n}\r\n"
    },
    "EventsQv/ProposalEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface proposalEvents{\r\n    event VoteCasted(address voter, uint256 ProposalID, uint256[] _tokens);\r\n// _voters,_creator,_startTime,_expirationTime,_disc,_cand\r\n    event ProposalCreated(\r\n        uint proposalId,\r\n        address[] voters,\r\n        address creator,\r\n        uint256 startTime,\r\n        uint256 expirationTime,\r\n        string description,\r\n        string[] _cand\r\n    );\r\n}"
    },
    "Library/VoterLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nlibrary voterLibrary {\r\n    struct voter {\r\n        uint256 proposalId;\r\n        address voterAddress;\r\n        bool hasVoted;\r\n        uint256 voteNum;\r\n        bool burn;\r\n    }\r\n\r\n    // hasVoted - direct check by self.hasVoted\r\n    // function hasVoted(voter storage self) internal returns(bool){\r\n    //   require(self.proposalId!=0,\"Invalid voter!\");\r\n    //   return self.hasVoted;\r\n    // }\r\n    // hasEnoughToken - direct use karega\r\n    // function hasEnoughToken(voter storage self, uint256 _voteCast) internal returns(bool){\r\n    //   require(self.proposalId!=0,\"Invalid voter!\");\r\n    //   require(!self.hasVoted, \"already voted\");\r\n    //   require(self.voteNum >=_voteCast, \"not have enough token\");\r\n    //   return true;\r\n    // }\r\n    // updatevoteNum after vote_Cast\r\n    function updateVoteNum(voter storage self) internal returns (bool) {\r\n        require(self.proposalId != 0, \"Invalid voter for proposalId!\");\r\n        require(!self.hasVoted, \"not voted\");\r\n        self.voteNum = 0;\r\n        return true;\r\n    }\r\n\r\n    // createVoter\r\n    function createVoter(\r\n        voter storage self,\r\n        uint256 _proposalId,\r\n        address _voterAddress,\r\n        bool _hasVoted,\r\n        uint256 _voteNum\r\n    ) internal returns (bool) {\r\n        self.proposalId = _proposalId;\r\n        self.voterAddress = _voterAddress;\r\n        self.hasVoted = _hasVoted;\r\n        self.voteNum = _voteNum;\r\n        self.burn = false;\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "Library/ProposalLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// import \"VoterLibrary.sol\";\r\n\r\nlibrary proposalLibrary {\r\n    struct proposal {\r\n        // uint256 proposalId;\r\n        address creator;\r\n        uint8 status;\r\n        string disc;\r\n        // address[] voters;\r\n        uint256 startTime;\r\n        uint256 expirationTime;\r\n        uint16 numOfOptions;\r\n        uint256 voteRight;\r\n        mapping(address => bool) voters;\r\n        uint256 winnerCount;\r\n        // mapping(address => voter) voterInfo;\r\n\r\n        // option -> option || replace\r\n        // create proposal props\r\n        mapping(string => bool) option;\r\n        mapping(uint256 => string) optionHash;\r\n        // respose proposal props\r\n        mapping(uint256 => string) result;\r\n        mapping(string => uint256) votes;\r\n    }\r\n\r\n    // create proposal\r\n    function createProposal(\r\n        proposal storage self,\r\n        uint8 _status,\r\n        address[] memory _voters,\r\n        address _creator,\r\n        uint256 _startTime,\r\n        uint256 _expirationTime,\r\n        string memory _disc,\r\n        uint256 _voteRight,\r\n        string[] calldata _option\r\n    ) internal returns (bool) {\r\n        self.creator = _creator;\r\n        self.status = _status;\r\n        self.disc = _disc;\r\n        self.startTime = _startTime;\r\n        self.expirationTime = _expirationTime;\r\n        self.numOfOptions = uint16(_option.length);\r\n        self.voteRight = _voteRight;\r\n        for (uint256 i = 0; i < _option.length; i++) {\r\n            self.option[_option[i]] = true;\r\n            self.optionHash[i + 1] = _option[i];\r\n        }\r\n        for (uint256 i = 0; i < _voters.length; i++) {\r\n            self.voters[_voters[i]] = true;\r\n        }\r\n        self.winnerCount = 3;\r\n        return true;\r\n    }\r\n\r\n    // take response\r\n    function responseProposal(\r\n        proposal storage self,\r\n        address _voter,\r\n        string[] memory _hash,\r\n        uint256[] memory v\r\n    ) internal returns (bool) {\r\n        require(self.status == 2, \"Proposal: inactive\");\r\n        require(block.timestamp <= self.startTime, \"proposal not started yet\");\r\n        if (block.timestamp > self.expirationTime) {\r\n            return false;\r\n        }\r\n\r\n        // if active\r\n        require(self.voters[_voter], \"Not a valid voter for this proposal\");\r\n        for (uint16 i = 0; i < self.numOfOptions; i++) {\r\n            require(self.option[_hash[i]], \"Proposal: invalid optionHash\");\r\n            self.votes[_hash[i]] += v[i];\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function proposalresult(proposal storage self) internal returns (bool) {\r\n        require(\r\n            block.timestamp > self.expirationTime,\r\n            \"Proposal hasn't ended yet!\"\r\n        );\r\n        // answer || result aayega\r\n        self.status = 3;\r\n        uint256 largestCount = self.votes[self.optionHash[1]];\r\n        uint256 _winnerCount = 1;\r\n        self.result[1] = self.optionHash[1];\r\n        // this for loop is used to find the winner count\r\n        for (uint16 i = 2; i <= self.numOfOptions; i++) {\r\n            if (self.votes[self.optionHash[i]] > largestCount) {\r\n                largestCount = self.votes[self.optionHash[i]];\r\n                _winnerCount = 1;\r\n                self.result[1] = self.optionHash[i];\r\n            } else if (self.votes[self.optionHash[i]] == largestCount) {\r\n                _winnerCount++;\r\n                self.result[_winnerCount] = self.optionHash[i];\r\n            }\r\n        }\r\n        self.winnerCount = _winnerCount;\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "Library/UserProposalLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nlibrary UserProposalLibrary{\r\n    struct UserProposal{\r\n    \r\n    // createCount\r\n    uint128 proposalCount;\r\n\r\n    // resposeCount\r\n    uint128 responseCount;\r\n\r\n     // poll creation property\r\n    mapping(uint128 => uint) proposalCreated; \r\n    \r\n    // poll response property\r\n    mapping(uint128 => uint) proposalResponsed; // response kis pollId par aaya hain\r\n    mapping(uint => mapping(uint => string)) proposalAnswer; //pollId => answerHash  \r\n    mapping(uint => bool) responsedProposal; \r\n\r\n    }\r\n    function updateProposalList(UserProposal storage self, uint _proposalId) internal returns(bool){\r\n        self.proposalCount++;\r\n        self.proposalCreated[self.proposalCount] = _proposalId;\r\n        return true;\r\n    }\r\n\r\n    function updateResponseList(UserProposal storage self, uint _proposalId, string[] memory _hash) internal returns(bool){\r\n        self.responseCount++;  \r\n        self.proposalResponsed[self.responseCount] = _proposalId;\r\n        // uint len =_hash.length();\r\n        // for(uint i=0;i<len;i++){\r\n        //     self.proposalAnswer[_proposalId][i+1] = _hash[i];\r\n        // }\r\n        for(uint16 i=0;i<_hash.length;i++){\r\n            self.proposalAnswer[_proposalId][i+1] = _hash[i];\r\n        }\r\n        self.responsedProposal[_proposalId] = true;\r\n        return true;\r\n    }\r\n\r\n\r\n}"
    },
    "QvToken/QvToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./ERC20.sol\";\r\n\r\ncontract QVtoken is ERC20 {\r\n    address private owner;\r\n\r\n    constructor() ERC20(\"QVotingToken\", \"Qv\") {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner(address msgSender) {\r\n        require(owner == msgSender);\r\n        _;\r\n    }\r\n\r\n    function checkAdmin() public view returns (bool) {\r\n        if (msg.sender == owner) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function mint(address to, uint256 amount) internal onlyOwner(_msgSender()) {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function burn(address to, uint256 amount) internal onlyOwner(_msgSender()) {\r\n        _burn(to, amount);\r\n    }\r\n}\r\n"
    },
    "QvToken/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IERC20Metadata.sol\";\r\nimport \"./Context.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\n \r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        // _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit mintAndburn(\"mint\",account, amount);\r\n\r\n        // _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n    \r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        // _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit mintAndburn(\"burn\",account, amount);\r\n\r\n        // _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    // function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n    //     address owner = _msgSender();\r\n    //     _transfer(owner, to, amount);\r\n    //     return true;\r\n    // }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n    //  */\r\n    // function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n    //     return _allowances[owner][spender];\r\n    // }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    // function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n    //     address owner = _msgSender();\r\n    //     _approve(owner, spender, amount);\r\n    //     return true;\r\n    // }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    // function transferFrom(\r\n    //     address from,\r\n    //     address to,\r\n    //     uint256 amount\r\n    // ) public virtual override returns (bool) {\r\n    //     address spender = _msgSender();\r\n    //     _spendAllowance(from, spender, amount);\r\n    //     _transfer(from, to, amount);\r\n    //     return true;\r\n    // }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    // function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n    //     address owner = _msgSender();\r\n    //     _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n    //     return true;\r\n    // }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    // function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n    //     address owner = _msgSender();\r\n    //     uint256 currentAllowance = allowance(owner, spender);\r\n    //     require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n    //     unchecked {\r\n    //         _approve(owner, spender, currentAllowance - subtractedValue);\r\n    //     }\r\n\r\n    //     return true;\r\n    // }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    // function _transfer(\r\n    //     address from,\r\n    //     address to,\r\n    //     uint256 amount\r\n    // ) internal virtual {\r\n    //     require(from != address(0), \"ERC20: transfer from the zero address\");\r\n    //     require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n    //     _beforeTokenTransfer(from, to, amount);\r\n\r\n    //     uint256 fromBalance = _balances[from];\r\n    //     require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n    //     unchecked {\r\n    //         _balances[from] = fromBalance - amount;\r\n    //     }\r\n    //     _balances[to] += amount;\r\n\r\n    //     emit Transfer(from, to, amount);\r\n\r\n    //     _afterTokenTransfer(from, to, amount);\r\n    // }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    // function _mint(address account, uint256 amount) internal virtual {\r\n    //     require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n    //     // _beforeTokenTransfer(address(0), account, amount);\r\n\r\n    //     _totalSupply += amount;\r\n    //     _balances[account] += amount;\r\n    //     emit mintAndburn(\"mint\",account, amount);\r\n\r\n    //     // _afterTokenTransfer(address(0), account, amount);\r\n    // }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n\r\n     \r\n    // function _burn(address account, uint256 amount) internal virtual {\r\n    //     require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n    //     // _beforeTokenTransfer(account, address(0), amount);\r\n\r\n    //     uint256 accountBalance = _balances[account];\r\n    //     require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n    //     unchecked {\r\n    //         _balances[account] = accountBalance - amount;\r\n    //     }\r\n    //     _totalSupply -= amount;\r\n\r\n    //     emit mintAndburn(\"burn\",account, amount);\r\n\r\n    //     // _afterTokenTransfer(account, address(0), amount);\r\n    // }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    // function _approve(\r\n    //     address owner,\r\n    //     address spender,\r\n    //     uint256 amount\r\n    // ) internal virtual {\r\n    //     require(owner != address(0), \"ERC20: approve from the zero address\");\r\n    //     require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n    //     _allowances[owner][spender] = amount;\r\n    //     emit Approval(owner, spender, amount);\r\n    // }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n    //  */\r\n    // function _spendAllowance(\r\n    //     address owner,\r\n    //     address spender,\r\n    //     uint256 amount\r\n    // ) internal virtual {\r\n    //     uint256 currentAllowance = allowance(owner, spender);\r\n    //     if (currentAllowance != type(uint256).max) {\r\n    //         require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n    //         unchecked {\r\n    //             _approve(owner, spender, currentAllowance - amount);\r\n    //         }\r\n    //     }\r\n    // }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    // function _beforeTokenTransfer(\r\n    //     address from,\r\n    //     address to,\r\n    //     uint256 amount\r\n    // ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    // function _afterTokenTransfer(\r\n    //     address from,\r\n    //     address to,\r\n    //     uint256 amount\r\n    // ) internal virtual {}\r\n}\r\n"
    },
    "QvToken/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n"
    },
    "QvToken/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    // event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    // event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    event mintAndburn(string mintAndburn, address account, uint256 amount);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    // function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    // function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    // function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    // function transferFrom(\r\n    //     address from,\r\n    //     address to,\r\n    //     uint256 amount\r\n    // ) external returns (bool);\r\n}\r\n"
    },
    "QvToken/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}